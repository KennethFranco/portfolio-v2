"use strict";
/*!
 * reading-time
 * Copyright (c) Nicolas Gryman <ngryman@gmail.com>
 * MIT Licensed
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.readingTimeWithCount = exports.countWords = void 0;
function codeIsInRanges(number, arrayOfRanges) {
    return arrayOfRanges.some(function (_a) {
        var lowerBound = _a[0], upperBound = _a[1];
        return (lowerBound <= number) && (number <= upperBound);
    });
}
var isCJK = function (c) {
    var charCode = c.charCodeAt(0);
    // Help wanted!
    // This should be good for most cases, but if you find it unsatisfactory
    // (e.g. some other language where each character should be standalone words),
    // contributions welcome!
    return codeIsInRanges(charCode, [
        // Hiragana (Katakana not included on purpose,
        // context: https://github.com/ngryman/reading-time/pull/35#issuecomment-853364526)
        // If you think Katakana should be included and have solid reasons, improvement is welcomed
        [0x3040, 0x309f],
        // CJK Unified ideographs
        [0x4e00, 0x9fff],
        // Hangul
        [0xac00, 0xd7a3],
        // CJK extensions
        [0x20000, 0x2ebe0]
    ]);
};
var isAnsiWordBound = function (c) {
    return ' \n\r\t'.includes(c);
};
var isPunctuation = function (c) {
    var charCode = c.charCodeAt(0);
    return codeIsInRanges(charCode, [
        [0x21, 0x2f],
        [0x3a, 0x40],
        [0x5b, 0x60],
        [0x7b, 0x7e],
        // CJK Symbols and Punctuation
        [0x3000, 0x303f],
        // Full-width ASCII punctuation variants
        [0xff00, 0xffef]
    ]);
};
function countWords(text, options) {
    if (options === void 0) { options = {}; }
    var words = 0, start = 0, end = text.length - 1;
    var _a = options.wordBound, isWordBound = _a === void 0 ? isAnsiWordBound : _a;
    // fetch bounds
    while (isWordBound(text[start]))
        start++;
    while (isWordBound(text[end]))
        end--;
    // Add a trailing word bound to make handling edges more convenient
    var normalizedText = text + "\n";
    // calculate the number of words
    for (var i = start; i <= end; i++) {
        // A CJK character is a always word;
        // A non-word bound followed by a word bound / CJK is the end of a word.
        if (isCJK(normalizedText[i]) ||
            (!isWordBound(normalizedText[i]) &&
                (isWordBound(normalizedText[i + 1]) || isCJK(normalizedText[i + 1])))) {
            words++;
        }
        // In case of CJK followed by punctuations, those characters have to be eaten as well
        if (isCJK(normalizedText[i])) {
            while (i <= end &&
                (isPunctuation(normalizedText[i + 1]) || isWordBound(normalizedText[i + 1]))) {
                i++;
            }
        }
    }
    return { total: words };
}
exports.countWords = countWords;
function readingTimeWithCount(words, options) {
    if (options === void 0) { options = {}; }
    var _a = options.wordsPerMinute, wordsPerMinute = _a === void 0 ? 200 : _a;
    // reading time stats
    var minutes = words.total / wordsPerMinute;
    // Math.round used to resolve floating point funkiness
    //   http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
    var time = Math.round(minutes * 60 * 1000);
    var displayed = Math.ceil(parseFloat(minutes.toFixed(2)));
    return {
        minutes: displayed,
        time: time
    };
}
exports.readingTimeWithCount = readingTimeWithCount;
function readingTime(text, options) {
    if (options === void 0) { options = {}; }
    var words = countWords(text, options);
    return __assign(__assign({}, readingTimeWithCount(words, options)), { words: words });
}
exports["default"] = readingTime;
