"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.displayErrorLog = displayErrorLog;
exports.formatLogMessageLogfile = formatLogMessageLogfile;
exports.formatLogMessageOneLine = formatLogMessageOneLine;
exports.logEmitter = void 0;
exports.logToTaskOutput = logToTaskOutput;
exports.setupLogging = setupLogging;
exports.writeErrorLogFile = writeErrorLogFile;

var _events = _interopRequireDefault(require("events"));

var _bfj = _interopRequireDefault(require("bfj"));

var _figures = _interopRequireDefault(require("figures"));

var _format = _interopRequireDefault(require("date-fns/format"));

var _parseISO = _interopRequireDefault(require("date-fns/parseISO"));

var _getEntityName = _interopRequireDefault(require("./get-entity-name"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const logEmitter = new _events.default();
exports.logEmitter = logEmitter;

function extractErrorInformation(error) {
  const source = error.originalError || error;

  try {
    const data = JSON.parse(source.message);

    if (data && typeof data === 'object') {
      return data;
    }
  } catch (err) {
    throw new Error('Unable to extract API error data');
  }
}

function formatLogMessageOneLine(logMessage) {
  const {
    level
  } = logMessage;

  if (!level) {
    return logMessage.toString().replace(/\s+/g, ' ');
  }

  if (level === 'info') {
    return logMessage.info;
  }

  if (level === 'warning') {
    return logMessage.warning;
  }

  try {
    // Display enhanced API error message when available
    const errorOutput = [];
    const data = extractErrorInformation(logMessage.error);

    if ('status' in data || 'statusText' in data) {
      const status = [data.status, data.statusText].filter(a => a).join(' - ');
      errorOutput.push(`Status: ${status}`);
    }

    if ('message' in data) {
      errorOutput.push(`Message: ${data.message}`);
    }

    if ('entity' in data) {
      errorOutput.push(`Entity: ${(0, _getEntityName.default)(data.entity)}`);
    }

    if ('details' in data && 'errors' in data.details) {
      const errorList = data.details.errors.map(error => error.details || error.name);
      errorOutput.push(`Details: ${errorList.join(', ')}`);
    }

    if ('requestId' in data) {
      errorOutput.push(`Request ID: ${data.requestId}`);
    }

    return `${logMessage.error.name}: ${errorOutput.join(' - ')}`;
  } catch (err) {
    // Fallback for errors without API information
    return logMessage.error.toString().replace(/\s+/g, ' ');
  }
}

function formatLogMessageLogfile(logMessage) {
  const {
    level
  } = logMessage;

  if (level === 'info' || level === 'warning') {
    return logMessage;
  }

  if (!logMessage.error) {
    // Enhance node errors to logMessage format
    logMessage.error = logMessage;
  }

  try {
    // Enhance error with extracted API error log
    const data = extractErrorInformation(logMessage.error);
    const errorOutput = Object.assign({}, logMessage.error, {
      data
    });
    delete errorOutput.message;
    logMessage.error = errorOutput;
  } catch (err) {
    // Fallback for errors without API information
    if (logMessage.error.stack) {
      logMessage.error.stacktrace = logMessage.error.stack.toString().split(/\n +at /);
    }
  } // Listr attaches the whole context to error messages.
  // Remove it to avoid error log file pollution.


  if (typeof logMessage.error === 'object' && 'context' in logMessage.error) {
    delete logMessage.error.context;
  }

  return logMessage;
} // Display all errors


function displayErrorLog(errorLog) {
  if (errorLog.length) {
    const count = errorLog.reduce((count, curr) => {
      if (Object.prototype.hasOwnProperty.call(curr, 'warning')) count.warnings++;else if (Object.prototype.hasOwnProperty.call(curr, 'error')) count.errors++;
      return count;
    }, {
      warnings: 0,
      errors: 0
    });
    console.log(`\n\nThe following ${count.errors} errors and ${count.warnings} warnings occurred:\n`);
    errorLog.map(logMessage => `${(0, _format.default)((0, _parseISO.default)(logMessage.ts), 'HH:mm:ss')} - ${formatLogMessageOneLine(logMessage)}`).map(logMessage => console.log(logMessage));
    return;
  }

  console.log('No errors or warnings occurred');
} // Write all log messages instead of infos to the error log file


function writeErrorLogFile(destination, errorLog) {
  const logFileData = errorLog.map(formatLogMessageLogfile);
  return _bfj.default.write(destination, logFileData, {
    circular: 'ignore',
    space: 2
  }).then(() => {
    console.log('\nStored the detailed error log file at:');
    console.log(destination);
  }).catch(e => {
    // avoid crashing when writing the log file fails
    console.error(e);
  });
} // Init listeners for log messages, transform them into proper format and logs/displays them


function setupLogging(log) {
  function errorLogger(level, error) {
    const logMessage = {
      ts: new Date().toJSON(),
      level,
      [level]: error
    };

    if (level !== 'info') {
      log.push(logMessage);
    }

    logEmitter.emit('display', logMessage);
  }

  logEmitter.addListener('info', error => errorLogger('info', error));
  logEmitter.addListener('warning', error => errorLogger('warning', error));
  logEmitter.addListener('error', error => errorLogger('error', error));
} // Format log message to display them as task status


function logToTaskOutput(task) {
  function logToTask(logMessage) {
    const content = formatLogMessageOneLine(logMessage);
    const symbols = {
      info: _figures.default.tick,
      warning: _figures.default.warning,
      error: _figures.default.cross
    };
    task.output = `${symbols[logMessage.level]} ${content}`.trim();
  }

  const startTime = Date.now();
  logEmitter.on('display', logToTask);
  return () => {
    const seconds = Math.ceil((Date.now() - startTime) / 1000);
    task.title = `${task.title} (${seconds}s)`;
    logEmitter.removeListener('display', logToTask);
  };
}